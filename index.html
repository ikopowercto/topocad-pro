<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TopoCAD Pro v1.2 - Import DXF/DWG</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/dxf-parser@1.5.0/dist/dxf-parser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; overflow: hidden; background: #f3f4f6; }
        .app-container { display: flex; flex-direction: column; height: 100vh; }
        .main-content { display: flex; flex: 1; overflow: hidden; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1rem 2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header-content { display: flex; align-items: center; justify-content: space-between; }
        .logo { display: flex; align-items: center; gap: 1rem; }
        .logo-icon { width: 40px; height: 40px; background: white; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; }
        .sidebar { width: 320px; background: white; border-right: 1px solid #e5e7eb; overflow-y: auto; }
        .sidebar-section { padding: 1.5rem; border-bottom: 1px solid #e5e7eb; }
        .section-title { font-size: 0.875rem; font-weight: 600; color: #374151; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 1rem; }
        .viewer-container { flex: 1; position: relative; background: #1f2937; }
        #canvas3d { width: 100%; height: 100%; display: block; }
        .btn { padding: 0.625rem 1.25rem; border-radius: 0.5rem; border: none; font-weight: 500; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; transform: translateY(-1px); }
        .btn-success { background: #10b981; color: white; }
        .btn-success:hover { background: #059669; }
        .btn-secondary { background: #6b7280; color: white; }
        .btn-tool { background: #f3f4f6; color: #374151; width: 100%; justify-content: flex-start; margin-bottom: 0.5rem; }
        .btn-tool.active { background: #3b82f6; color: white; }
        .input-group { margin-bottom: 1rem; }
        .input-label { display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem; }
        select, input[type="range"] { width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 1rem; border-radius: 0.5rem; color: white; margin-bottom: 0.75rem; }
        .stat-value { font-size: 1.5rem; font-weight: 700; margin-bottom: 0.25rem; }
        .stat-label { font-size: 0.75rem; opacity: 0.9; }
        .diagnostic-panel { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 1rem; max-height: 300px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.75rem; }
        .diagnostic-success { color: #059669; }
        .diagnostic-info { color: #3b82f6; }
        .diagnostic-warning { color: #f59e0b; }
        .diagnostic-error { color: #dc2626; }
        .dropzone { border: 2px dashed #d1d5db; border-radius: 0.5rem; padding: 2rem; text-align: center; cursor: pointer; transition: all 0.2s; background: #f9fafb; }
        .dropzone:hover { border-color: #3b82f6; background: #eff6ff; }
        .dropzone.active { border-color: #3b82f6; background: #dbeafe; }
        .hidden { display: none !important; }
        .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; }
        .spinner { border: 3px solid #f3f4f6; border-top: 3px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .overlay { position: absolute; top: 1rem; right: 1rem; background: rgba(255,255,255,0.95); padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 20px rgba(0,0,0,0.1); font-size: 0.75rem; }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-icon">üìê</div>
                    <div>
                        <h1 style="font-size: 1.5rem; font-weight: 700;">TopoCAD Pro v1.2</h1>
                        <p style="font-size: 0.875rem; opacity: 0.9;">Import DXF/DWG - Traitement Topographique</p>
                    </div>
                </div>
                <button class="btn btn-primary" onclick="APP.showHelp()">‚ùì Aide</button>
            </div>
        </header>
        
        <div class="main-content">
            <aside class="sidebar">
                <div class="sidebar-section">
                    <h2 class="section-title">üì• Import Fichier</h2>
                    <div class="dropzone" id="dropzone">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">üìÅ</div>
                        <p style="font-weight: 600; margin-bottom: 0.5rem;">Glissez votre fichier ici</p>
                        <p style="font-size: 0.75rem; color: #6b7280; margin-bottom: 1rem;">DXF ou DWG accept√©s</p>
                        <input type="file" id="fileInput" accept=".dxf,.dwg" class="hidden">
                        <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">üìÅ Choisir un fichier</button>
                    </div>
                    <div id="loadingIndicator" class="hidden" style="margin-top: 1rem;">
                        <div class="spinner"></div>
                        <p style="text-align: center; margin-top: 0.5rem; font-size: 0.875rem; color: #6b7280;">Chargement...</p>
                    </div>
                </div>
                
                <div class="sidebar-section">
                    <h2 class="section-title">üõ†Ô∏è Outils</h2>
                    <button class="btn-tool active" data-tool="view" onclick="APP.setTool('view')">üëÅÔ∏è Navigation 3D</button>
                    <button class="btn-tool" data-tool="select" onclick="APP.setTool('select')">‚¨ú S√©lection</button>
                    <button class="btn-tool" data-tool="measure" onclick="APP.setTool('measure')">üìè Mesure</button>
                </div>
                
                <div class="sidebar-section hidden" id="statsSection">
                    <h2 class="section-title">üìä Statistiques</h2>
                    <div class="grid-2">
                        <div class="stat-card">
                            <div class="stat-value" id="statEntities">0</div>
                            <div class="stat-label">Entit√©s</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statPoints">0</div>
                            <div class="stat-label">Points altim√©triques</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label" style="margin-bottom: 0.5rem;">Altitude</div>
                        <div style="display: flex; justify-content: space-between;">
                            <div><strong>Min:</strong> <span id="statMinElev">-</span></div>
                            <div><strong>Max:</strong> <span id="statMaxElev">-</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="sidebar-section hidden" id="layersSection">
                    <h2 class="section-title">üìã Layers</h2>
                    <div id="layersList" style="max-height: 200px; overflow-y: auto;"></div>
                </div>
                
                <div class="sidebar-section hidden" id="params3DSection">
                    <h2 class="section-title">‚öôÔ∏è Param√®tres 3D</h2>
                    <div class="input-group">
                        <label class="input-label">Exag√©ration verticale: <span id="exagValue">2x</span></label>
                        <input type="range" id="exagSlider" min="1" max="10" value="2" step="0.5">
                    </div>
                    <div class="input-group">
                        <label class="input-label">
                            <input type="checkbox" id="showGrid" checked> Afficher la grille
                        </label>
                    </div>
                    <div class="input-group">
                        <label class="input-label">
                            <input type="checkbox" id="showAxes" checked> Afficher les axes
                        </label>
                    </div>
                </div>
                
                <div class="sidebar-section hidden" id="exportSection">
                    <h2 class="section-title">üíæ Export</h2>
                    <button class="btn btn-success" style="width: 100%; margin-bottom: 0.5rem;" onclick="APP.exportDXF()">üì¶ Export DXF 3D</button>
                    <button class="btn btn-secondary" style="width: 100%; margin-bottom: 0.5rem;" onclick="APP.exportCSV()">üìÑ Export CSV Points</button>
                    <button class="btn btn-secondary" style="width: 100%;" onclick="APP.exportJSON()">üíæ Export Projet</button>
                </div>
                
                <div class="sidebar-section">
                    <h2 class="section-title">üîç Diagnostic</h2>
                    <button class="btn btn-secondary" style="width: 100%; font-size: 0.75rem;" onclick="APP.toggleDiagnostic()">
                        <span id="diagnosticToggleText">Afficher diagnostic</span>
                    </button>
                    <div id="diagnosticPanel" class="diagnostic-panel hidden" style="margin-top: 1rem;">
                        <div id="diagnosticContent">En attente d'import...</div>
                    </div>
                </div>
            </aside>
            
            <div class="viewer-container">
                <canvas id="canvas3d"></canvas>
                <div class="overlay">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">CONTR√îLES 3D</div>
                    <div>üñ±Ô∏è Clic gauche: Rotation<br>üñ±Ô∏è Clic droit: D√©placement<br>üñ±Ô∏è Molette: Zoom</div>
                </div>
                <div id="noDataMessage" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white;">
                    <div style="font-size: 4rem; margin-bottom: 1rem;">üìê</div>
                    <h2 style="font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem;">TopoCAD Pro v1.2</h2>
                    <p style="font-size: 1rem; opacity: 0.8;">Importez un fichier DXF ou DWG pour commencer</p>
                    <p style="font-size: 0.875rem; opacity: 0.6; margin-top: 1rem;">Convertissez d'abord votre PDF en DXF/DWG</p>
                </div>
            </div>
        </div>
    </div>

    <script>
const APP = {
    state: {
        dxf: null,
        entities: [],
        points: [],
        layers: {},
        currentTool: 'view',
        scene: null,
        camera: null,
        renderer: null,
        meshes: [],
        exaggeration: 2
    },
    
    async loadFile(file) {
        try {
            this.showLoading(true);
            this.log(`üìÇ Chargement de ${file.name}...`, 'info');
            
            const text = await file.text();
            const parser = new window.DxfParser();
            
            try {
                const dxf = parser.parseSync(text);
                this.state.dxf = dxf;
                this.log(`‚úÖ Fichier DXF charg√© avec succ√®s`, 'success');
                this.processDXF(dxf);
            } catch (err) {
                this.log(`‚ö†Ô∏è Tentative de lecture comme DWG...`, 'warning');
                this.log(`‚ùå Format DWG non support√© directement. Convertissez en DXF d'abord.`, 'error');
                alert('Les fichiers DWG ne sont pas directement support√©s.\n\nConvertissez votre fichier DWG en DXF avec:\n- AutoCAD\n- LibreCAD\n- Convertisseur en ligne');
            }
            
            this.showLoading(false);
        } catch (error) {
            this.log(`‚ùå Erreur: ${error.message}`, 'error');
            this.showLoading(false);
            alert('Erreur lors du chargement du fichier');
        }
    },
    
    processDXF(dxf) {
        this.log(`üìä Analyse du fichier DXF...`, 'info');
        
        // Extraire les entit√©s
        this.state.entities = [];
        this.state.layers = {};
        
        if (dxf.entities) {
            dxf.entities.forEach(entity => {
                this.state.entities.push(entity);
                
                // Compter par layer
                const layer = entity.layer || '0';
                this.state.layers[layer] = (this.state.layers[layer] || 0) + 1;
            });
        }
        
        this.log(`‚úÖ ${this.state.entities.length} entit√©s trouv√©es`, 'success');
        this.log(`üìã ${Object.keys(this.state.layers).length} layers d√©tect√©s`, 'info');
        
        // Extraire les points d'altitude
        this.extractElevationPoints();
        
        // Afficher les stats
        this.updateStats();
        this.updateLayers();
        
        // Initialiser la 3D
        this.init3D();
        this.render3D();
        
        // Afficher les sections
        document.getElementById('statsSection').classList.remove('hidden');
        document.getElementById('layersSection').classList.remove('hidden');
        document.getElementById('params3DSection').classList.remove('hidden');
        document.getElementById('exportSection').classList.remove('hidden');
        document.getElementById('noDataMessage').classList.add('hidden');
    },
    
    extractElevationPoints() {
        this.state.points = [];
        
        // Patterns d'altitude √† rechercher dans les textes
        const patterns = [
            { name: 'NE=XXX.XX', regex: /NE\s*=\s*(\d{2,3}[.,]\d{1,2})/i },
            { name: 'NGF=XXX.XX', regex: /NGF\s*=\s*(\d{2,3}[.,]\d{1,2})/i },
            { name: 'Z=XXX.XX', regex: /Z\s*=\s*(\d{2,3}[.,]\d{1,2})/i },
            { name: 'XXX.XX isol√©', regex: /^(\d{2,3}[.,]\d{1,2})$/i },
            { name: 'XXX.XXm', regex: /(\d{2,3}[.,]\d{1,2})\s*m/i }
        ];
        
        this.state.entities.forEach(entity => {
            if (entity.type === 'TEXT' || entity.type === 'MTEXT') {
                const text = entity.text || '';
                
                patterns.forEach(pattern => {
                    const match = text.match(pattern.regex);
                    if (match) {
                        const elevStr = match[1].replace(',', '.');
                        const elevation = parseFloat(elevStr);
                        
                        if (elevation > 0 && elevation < 5000) {
                            this.state.points.push({
                                x: entity.position?.x || entity.startPoint?.x || 0,
                                y: entity.position?.y || entity.startPoint?.y || 0,
                                z: elevation,
                                elevation: elevation,
                                text: text,
                                source: pattern.name,
                                layer: entity.layer
                            });
                            this.log(`‚úì Point trouv√©: ${text} (${elevation}m) sur layer "${entity.layer}"`, 'success');
                        }
                    }
                });
            }
        });
        
        this.log(`‚úÖ ${this.state.points.length} points d'altitude extraits`, 'success');
    },
    
    init3D() {
        const canvas = document.getElementById('canvas3d');
        const width = canvas.parentElement.offsetWidth;
        const height = canvas.parentElement.offsetHeight;
        
        this.state.scene = new THREE.Scene();
        this.state.scene.background = new THREE.Color(0x1f2937);
        
        this.state.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100000);
        this.state.camera.position.set(500, 500, 500);
        
        this.state.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        this.state.renderer.setSize(width, height);
        
        // Lumi√®res
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.state.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1000, 2000, 1000);
        this.state.scene.add(directionalLight);
        
        // Grille
        const gridHelper = new THREE.GridHelper(1000, 50, 0x888888, 0x444444);
        gridHelper.name = 'grid';
        this.state.scene.add(gridHelper);
        
        // Axes
        const axesHelper = new THREE.AxesHelper(500);
        axesHelper.name = 'axes';
        this.state.scene.add(axesHelper);
        
        this.setupControls();
        this.animate();
    },
    
    render3D() {
        // Supprimer les anciens meshes
        this.state.meshes.forEach(mesh => this.state.scene.remove(mesh));
        this.state.meshes = [];
        
        const exag = this.state.exaggeration;
        
        // Calculer les limites et moyenne
        let minElev = Infinity, maxElev = -Infinity;
        if (this.state.points.length > 0) {
            this.state.points.forEach(p => {
                if (p.elevation < minElev) minElev = p.elevation;
                if (p.elevation > maxElev) maxElev = p.elevation;
            });
        }
        const avgElev = (minElev + maxElev) / 2;
        
        // Rendu des entit√©s DXF
        this.state.entities.forEach(entity => {
            if (entity.type === 'LINE') {
                const points = [
                    new THREE.Vector3(entity.vertices[0].x, 0, entity.vertices[0].y),
                    new THREE.Vector3(entity.vertices[1].x, 0, entity.vertices[1].y)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                const line = new THREE.Line(geometry, material);
                this.state.scene.add(line);
                this.state.meshes.push(line);
            }
            else if (entity.type === 'LWPOLYLINE' || entity.type === 'POLYLINE') {
                const points = entity.vertices.map(v => 
                    new THREE.Vector3(v.x, 0, v.y)
                );
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                const line = new THREE.Line(geometry, material);
                this.state.scene.add(line);
                this.state.meshes.push(line);
            }
            else if (entity.type === 'CIRCLE') {
                const curve = new THREE.EllipseCurve(
                    entity.center.x, entity.center.y,
                    entity.radius, entity.radius,
                    0, 2 * Math.PI,
                    false, 0
                );
                const points = curve.getPoints(50).map(p => new THREE.Vector3(p.x, 0, p.y));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
                const line = new THREE.LineLoop(geometry, material);
                this.state.scene.add(line);
                this.state.meshes.push(line);
            }
            else if (entity.type === 'ARC') {
                const startAngle = entity.startAngle * Math.PI / 180;
                const endAngle = entity.endAngle * Math.PI / 180;
                const curve = new THREE.EllipseCurve(
                    entity.center.x, entity.center.y,
                    entity.radius, entity.radius,
                    startAngle, endAngle,
                    false, 0
                );
                const points = curve.getPoints(50).map(p => new THREE.Vector3(p.x, 0, p.y));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
                const line = new THREE.Line(geometry, material);
                this.state.scene.add(line);
                this.state.meshes.push(line);
            }
        });
        
        // Rendu des points d'altitude
        this.state.points.forEach(point => {
            const geometry = new THREE.SphereGeometry(5, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                metalness: 0.3,
                roughness: 0.4
            });
            
            const z3d = (point.elevation - avgElev) * exag;
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(point.x, z3d, point.y);
            sphere.userData = { point };
            
            this.state.scene.add(sphere);
            this.state.meshes.push(sphere);
        });
        
        this.fitCamera();
    },
    
    setupControls() {
        const canvas = document.getElementById('canvas3d');
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        let isRightClick = false;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            isRightClick = e.button === 2;
            previousMouse = { x: e.clientX, y: e.clientY };
            e.preventDefault();
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - previousMouse.x;
            const deltaY = e.clientY - previousMouse.y;
            
            if (isRightClick) {
                const distance = this.state.camera.position.length();
                const factor = distance * 0.001;
                this.state.camera.position.x -= deltaX * factor;
                this.state.camera.position.y += deltaY * factor;
            } else {
                const rotationSpeed = 0.005;
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(this.state.camera.position);
                spherical.theta -= deltaX * rotationSpeed;
                spherical.phi -= deltaY * rotationSpeed;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                this.state.camera.position.setFromSpherical(spherical);
                this.state.camera.lookAt(0, 0, 0);
            }
            
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        canvas.addEventListener('mouseup', () => { isDragging = false; });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const distance = this.state.camera.position.length();
            const newDistance = distance * (1 + (e.deltaY > 0 ? 0.1 : -0.1));
            this.state.camera.position.multiplyScalar(newDistance / distance);
        });
    },
    
    fitCamera() {
        if (this.state.meshes.length === 0) return;
        const box = new THREE.Box3();
        this.state.meshes.forEach(mesh => box.expandByObject(mesh));
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const distance = maxDim * 1.5;
        this.state.camera.position.set(center.x + distance, center.y + distance, center.z + distance);
        this.state.camera.lookAt(center);
    },
    
    animate() {
        requestAnimationFrame(() => this.animate());
        if (this.state.renderer && this.state.scene && this.state.camera) {
            this.state.renderer.render(this.state.scene, this.state.camera);
        }
    },
    
    exportDXF() {
        if (!this.state.points.length) return alert('Aucun point √† exporter');
        
        let dxf = "0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1009\n0\nENDSEC\n";
        dxf += "0\nSECTION\n2\nENTITIES\n";
        
        this.state.points.forEach(p => {
            dxf += `0\nPOINT\n8\nPOINTS_TOPO_3D\n10\n${p.x.toFixed(3)}\n20\n${p.y.toFixed(3)}\n30\n${p.z.toFixed(3)}\n`;
        });
        
        dxf += "0\nENDSEC\n0\nEOF\n";
        
        this.downloadFile(dxf, 'topocad_export_3d.dxf', 'application/dxf');
        this.log(`‚úÖ Export DXF 3D: ${this.state.points.length} points`, 'success');
    },
    
    exportCSV() {
        if (!this.state.points.length) return alert('Aucun point √† exporter');
        
        let csv = 'ID,X,Y,Z,Text,Source,Layer\n';
        this.state.points.forEach((p, i) => {
            csv += `${i+1},${p.x.toFixed(3)},${p.y.toFixed(3)},${p.z.toFixed(3)},"${p.text}",${p.source},${p.layer}\n`;
        });
        
        this.downloadFile(csv, 'topocad_points.csv', 'text/csv');
        this.log(`‚úÖ Export CSV: ${this.state.points.length} points`, 'success');
    },
    
    exportJSON() {
        const data = {
            version: '1.2',
            date: new Date().toISOString(),
            entities: this.state.entities.length,
            points: this.state.points,
            layers: this.state.layers
        };
        
        this.downloadFile(JSON.stringify(data, null, 2), 'topocad_project.json', 'application/json');
        this.log(`‚úÖ Projet export√©`, 'success');
    },
    
    downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    },
    
    setTool(tool) {
        this.state.currentTool = tool;
        document.querySelectorAll('.btn-tool').forEach(btn => btn.classList.remove('active'));
        document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
        this.log(`üõ†Ô∏è Outil: ${tool}`, 'info');
    },
    
    updateStats() {
        document.getElementById('statEntities').textContent = this.state.entities.length;
        document.getElementById('statPoints').textContent = this.state.points.length;
        
        if (this.state.points.length) {
            const elevs = this.state.points.map(p => p.elevation);
            document.getElementById('statMinElev').textContent = Math.min(...elevs).toFixed(2) + 'm';
            document.getElementById('statMaxElev').textContent = Math.max(...elevs).toFixed(2) + 'm';
        }
    },
    
    updateLayers() {
        const list = document.getElementById('layersList');
        list.innerHTML = '';
        
        Object.entries(this.state.layers).forEach(([name, count]) => {
            const div = document.createElement('div');
            div.style.cssText = 'padding: 0.5rem; background: #f9fafb; border-radius: 0.25rem; margin-bottom: 0.5rem; font-size: 0.75rem;';
            div.innerHTML = `<strong>${name}</strong>: ${count} entit√©s`;
            list.appendChild(div);
        });
    },
    
    showLoading(show) {
        document.getElementById('loadingIndicator').classList.toggle('hidden', !show);
    },
    
    log(message, type = 'info') {
        const content = document.getElementById('diagnosticContent');
        const time = new Date().toLocaleTimeString();
        const className = `diagnostic-${type}`;
        const line = document.createElement('div');
        line.className = className;
        line.textContent = `[${time}] ${message}`;
        content.appendChild(line);
        content.scrollTop = content.scrollHeight;
        console.log(message);
    },
    
    toggleDiagnostic() {
        const panel = document.getElementById('diagnosticPanel');
        panel.classList.toggle('hidden');
        document.getElementById('diagnosticToggleText').textContent = 
            panel.classList.contains('hidden') ? 'Afficher diagnostic' : 'Masquer diagnostic';
    },
    
    showHelp() {
        alert(
            'TopoCAD Pro v1.2 - Import DXF/DWG\n\n' +
            '1. CONVERSION:\n' +
            '   Convertissez votre PDF en DXF/DWG avec:\n' +
            '   - AutoCAD\n' +
            '   - LibreCAD\n' +
            '   - Convertisseur en ligne\n\n' +
            '2. IMPORT:\n' +
            '   Glissez votre fichier DXF\n\n' +
            '3. VISUALISATION:\n' +
            '   - Lignes/polylignes en vert\n' +
            '   - Points d\'altitude en rouge\n' +
            '   - Navigation 3D compl√®te\n\n' +
            '4. EXPORT:\n' +
            '   - DXF 3D avec altitudes\n' +
            '   - CSV des points\n' +
            '   - JSON du projet'
        );
    }
};

// INITIALISATION
document.addEventListener('DOMContentLoaded', () => {
    APP.log('üöÄ TopoCAD Pro v1.2 - Import DXF/DWG', 'success');
    
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            APP.loadFile(e.target.files[0]);
        }
    });
    
    dropzone.addEventListener('click', () => fileInput.click());
    
    dropzone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropzone.classList.add('active');
    });
    
    dropzone.addEventListener('dragleave', () => {
        dropzone.classList.remove('active');
    });
    
    dropzone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropzone.classList.remove('active');
        if (e.dataTransfer.files.length > 0) {
            APP.loadFile(e.dataTransfer.files[0]);
        }
    });
    
    document.getElementById('exagSlider').addEventListener('input', (e) => {
        document.getElementById('exagValue').textContent = e.target.value + 'x';
        APP.state.exaggeration = parseFloat(e.target.value);
        if (APP.state.entities.length) APP.render3D();
    });
    
    document.getElementById('showGrid').addEventListener('change', (e) => {
        const grid = APP.state.scene?.getObjectByName('grid');
        if (grid) grid.visible = e.target.checked;
    });
    
    document.getElementById('showAxes').addEventListener('change', (e) => {
        const axes = APP.state.scene?.getObjectByName('axes');
        if (axes) axes.visible = e.target.checked;
    });
});
    </script>
</body>
</html>
