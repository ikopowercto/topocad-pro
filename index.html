<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TopoCAD Pro v1.2.1 - Import DXF Robuste</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; overflow: hidden; background: #f3f4f6; }
        .app-container { display: flex; flex-direction: column; height: 100vh; }
        .main-content { display: flex; flex: 1; overflow: hidden; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1rem 2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header-content { display: flex; align-items: center; justify-content: space-between; }
        .logo { display: flex; align-items: center; gap: 1rem; }
        .logo-icon { width: 40px; height: 40px; background: white; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; }
        .sidebar { width: 320px; background: white; border-right: 1px solid #e5e7eb; overflow-y: auto; }
        .sidebar-section { padding: 1.5rem; border-bottom: 1px solid #e5e7eb; }
        .section-title { font-size: 0.875rem; font-weight: 600; color: #374151; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 1rem; }
        .viewer-container { flex: 1; position: relative; background: #1f2937; }
        #canvas3d { width: 100%; height: 100%; display: block; }
        .btn { padding: 0.625rem 1.25rem; border-radius: 0.5rem; border: none; font-weight: 500; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; transform: translateY(-1px); }
        .btn-success { background: #10b981; color: white; }
        .btn-success:hover { background: #059669; }
        .btn-secondary { background: #6b7280; color: white; }
        .btn-warning { background: #f59e0b; color: white; }
        .input-group { margin-bottom: 1rem; }
        .input-label { display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem; }
        select, input[type="range"] { width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 1rem; border-radius: 0.5rem; color: white; margin-bottom: 0.75rem; }
        .stat-value { font-size: 1.5rem; font-weight: 700; margin-bottom: 0.25rem; }
        .stat-label { font-size: 0.75rem; opacity: 0.9; }
        .diagnostic-panel { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 1rem; max-height: 400px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.75rem; }
        .diagnostic-success { color: #059669; }
        .diagnostic-info { color: #3b82f6; }
        .diagnostic-warning { color: #f59e0b; }
        .diagnostic-error { color: #dc2626; }
        .dropzone { border: 2px dashed #d1d5db; border-radius: 0.5rem; padding: 2rem; text-align: center; cursor: pointer; transition: all 0.2s; background: #f9fafb; }
        .dropzone:hover { border-color: #3b82f6; background: #eff6ff; }
        .dropzone.active { border-color: #3b82f6; background: #dbeafe; }
        .hidden { display: none !important; }
        .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; }
        .spinner { border: 3px solid #f3f4f6; border-top: 3px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .alert { padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; font-size: 0.875rem; }
        .alert-info { background: #dbeafe; color: #1e40af; border: 1px solid #93c5fd; }
        .alert-warning { background: #fef3c7; color: #92400e; border: 1px solid #fcd34d; }
        .alert-error { background: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-icon">üìê</div>
                    <div>
                        <h1 style="font-size: 1.5rem; font-weight: 700;">TopoCAD Pro v1.2.1</h1>
                        <p style="font-size: 0.875rem; opacity: 0.9;">Import DXF Robuste - Tous Formats</p>
                    </div>
                </div>
            </div>
        </header>
        
        <div class="main-content">
            <aside class="sidebar">
                <div class="sidebar-section">
                    <h2 class="section-title">üì• Import Fichier DXF</h2>
                    
                    <div class="alert alert-info" style="margin-bottom: 1rem;">
                        <strong>‚úÖ Formats support√©s:</strong><br>
                        ‚Ä¢ DXF ASCII (R12, R14, R2000, R2004, R2007, R2010, R2013, R2018)<br>
                        ‚Ä¢ Export√© depuis AutoCAD, LibreCAD, DraftSight, etc.
                    </div>
                    
                    <div class="dropzone" id="dropzone">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">üìÅ</div>
                        <p style="font-weight: 600; margin-bottom: 0.5rem;">Glissez votre fichier DXF ici</p>
                        <p style="font-size: 0.75rem; color: #6b7280; margin-bottom: 1rem;">Fichier .dxf uniquement (ASCII)</p>
                        <input type="file" id="fileInput" accept=".dxf" class="hidden">
                        <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">üìÅ Choisir un fichier DXF</button>
                    </div>
                    
                    <div id="errorAlert" class="alert alert-error hidden" style="margin-top: 1rem;"></div>
                    
                    <div id="loadingIndicator" class="hidden" style="margin-top: 1rem;">
                        <div class="spinner"></div>
                        <p style="text-align: center; margin-top: 0.5rem; font-size: 0.875rem; color: #6b7280;">Analyse du fichier...</p>
                    </div>
                </div>
                
                <div class="sidebar-section">
                    <h2 class="section-title">üîç Diagnostic (Toujours Visible)</h2>
                    <div id="diagnosticPanel" class="diagnostic-panel">
                        <div id="diagnosticContent">üöÄ TopoCAD Pro v1.2.1 - Pr√™t<br>üìñ Importez un fichier DXF pour commencer</div>
                    </div>
                </div>
                
                <div class="sidebar-section hidden" id="statsSection">
                    <h2 class="section-title">üìä Statistiques</h2>
                    <div class="grid-2">
                        <div class="stat-card">
                            <div class="stat-value" id="statEntities">0</div>
                            <div class="stat-label">Entit√©s</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statPoints">0</div>
                            <div class="stat-label">Points altitude</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div style="display: flex; justify-content: space-between;">
                            <div><strong>Min:</strong> <span id="statMinElev">-</span></div>
                            <div><strong>Max:</strong> <span id="statMaxElev">-</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="sidebar-section hidden" id="params3DSection">
                    <h2 class="section-title">‚öôÔ∏è Param√®tres 3D</h2>
                    <div class="input-group">
                        <label class="input-label">Exag√©ration verticale: <span id="exagValue">2x</span></label>
                        <input type="range" id="exagSlider" min="1" max="10" value="2" step="0.5">
                    </div>
                    <div class="input-group">
                        <label class="input-label">
                            <input type="checkbox" id="showGrid" checked> Grille
                        </label>
                    </div>
                </div>
                
                <div class="sidebar-section hidden" id="exportSection">
                    <h2 class="section-title">üíæ Export</h2>
                    <button class="btn btn-success" style="width: 100%; margin-bottom: 0.5rem;" onclick="APP.exportDXF()">üì¶ Export DXF 3D</button>
                    <button class="btn btn-secondary" style="width: 100%;" onclick="APP.exportCSV()">üìÑ Export CSV</button>
                </div>
            </aside>
            
            <div class="viewer-container">
                <canvas id="canvas3d"></canvas>
                <div id="noDataMessage" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white;">
                    <div style="font-size: 4rem; margin-bottom: 1rem;">üìê</div>
                    <h2 style="font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem;">TopoCAD Pro v1.2.1</h2>
                    <p style="font-size: 1rem; opacity: 0.8;">Importez un fichier DXF</p>
                    <p style="font-size: 0.875rem; opacity: 0.6; margin-top: 1rem;">Formats: R12, R14, R2000, R2004, R2007, R2010+</p>
                </div>
            </div>
        </div>
    </div>

    <script>
const APP = {
    state: {
        entities: [],
        points: [],
        scene: null,
        camera: null,
        renderer: null,
        meshes: [],
        exaggeration: 2
    },
    
    async loadFile(file) {
        try {
            this.showLoading(true);
            this.showError('');
            this.log(`üìÇ Chargement de ${file.name} (${(file.size/1024).toFixed(1)} KB)`, 'info');
            
            const text = await file.text();
            this.log(`‚úÖ Fichier lu: ${text.length} caract√®res`, 'success');
            
            // V√©rification basique
            if (!text.includes('SECTION') && !text.includes('ENTITIES')) {
                throw new Error('Fichier DXF invalide: pas de section ENTITIES trouv√©e');
            }
            
            this.log(`üîç Analyse du contenu DXF...`, 'info');
            this.parseDXFManual(text);
            
            this.showLoading(false);
        } catch (error) {
            this.log(`‚ùå ERREUR: ${error.message}`, 'error');
            this.showError(error.message);
            this.showLoading(false);
        }
    },
    
    parseDXFManual(text) {
        this.log(`üìä Parsing manuel du DXF...`, 'info');
        
        const lines = text.split('\n').map(l => l.trim());
        this.state.entities = [];
        this.state.points = [];
        
        let inEntities = false;
        let currentEntity = null;
        let groupCode = null;
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // D√©tection section ENTITIES
            if (line === 'ENTITIES') {
                inEntities = true;
                this.log(`‚úì Section ENTITIES trouv√©e`, 'success');
                continue;
            }
            
            if (line === 'ENDSEC' && inEntities) {
                inEntities = false;
                continue;
            }
            
            if (!inEntities) continue;
            
            // Lecture par paires (code, valeur)
            if (i % 2 === 0) {
                groupCode = line;
            } else {
                const value = line;
                
                // Nouvelle entit√©
                if (groupCode === '0') {
                    if (currentEntity) {
                        this.processEntity(currentEntity);
                    }
                    currentEntity = { type: value, data: {} };
                } else if (currentEntity) {
                    // Stocker la donn√©e
                    if (!currentEntity.data[groupCode]) {
                        currentEntity.data[groupCode] = [];
                    }
                    currentEntity.data[groupCode].push(value);
                }
            }
        }
        
        // Traiter la derni√®re entit√©
        if (currentEntity) {
            this.processEntity(currentEntity);
        }
        
        this.log(`‚úÖ ${this.state.entities.length} entit√©s trouv√©es`, 'success');
        this.log(`‚úÖ ${this.state.points.length} points d'altitude extraits`, 'success');
        
        if (this.state.entities.length === 0) {
            throw new Error('Aucune entit√© trouv√©e dans le DXF. V√©rifiez le format.');
        }
        
        this.updateStats();
        this.init3D();
        this.render3D();
        
        document.getElementById('statsSection').classList.remove('hidden');
        document.getElementById('params3DSection').classList.remove('hidden');
        document.getElementById('exportSection').classList.remove('hidden');
        document.getElementById('noDataMessage').classList.add('hidden');
    },
    
    processEntity(entity) {
        const type = entity.type;
        const data = entity.data;
        
        // Extraire coordonn√©es selon le type
        if (type === 'LINE') {
            const x1 = parseFloat(data['10']?.[0] || 0);
            const y1 = parseFloat(data['20']?.[0] || 0);
            const x2 = parseFloat(data['11']?.[0] || 0);
            const y2 = parseFloat(data['21']?.[0] || 0);
            
            this.state.entities.push({
                type: 'LINE',
                vertices: [{x: x1, y: y1}, {x: x2, y: y2}]
            });
        }
        else if (type === 'LWPOLYLINE' || type === 'POLYLINE') {
            // Polylignes complexes - simplifi√©
            const vertices = [];
            const xs = data['10'] || [];
            const ys = data['20'] || [];
            
            for (let i = 0; i < Math.min(xs.length, ys.length); i++) {
                vertices.push({
                    x: parseFloat(xs[i]),
                    y: parseFloat(ys[i])
                });
            }
            
            if (vertices.length > 0) {
                this.state.entities.push({ type: 'POLYLINE', vertices });
            }
        }
        else if (type === 'CIRCLE') {
            const x = parseFloat(data['10']?.[0] || 0);
            const y = parseFloat(data['20']?.[0] || 0);
            const r = parseFloat(data['40']?.[0] || 1);
            
            this.state.entities.push({
                type: 'CIRCLE',
                center: {x, y},
                radius: r
            });
        }
        else if (type === 'TEXT' || type === 'MTEXT') {
            const text = data['1']?.[0] || '';
            const x = parseFloat(data['10']?.[0] || 0);
            const y = parseFloat(data['20']?.[0] || 0);
            
            this.state.entities.push({
                type: 'TEXT',
                text: text,
                position: {x, y}
            });
            
            // Extraire altitude
            this.extractElevation(text, x, y);
        }
        else if (type === 'POINT') {
            const x = parseFloat(data['10']?.[0] || 0);
            const y = parseFloat(data['20']?.[0] || 0);
            const z = parseFloat(data['30']?.[0] || 0);
            
            if (z > 0) {
                this.state.points.push({
                    x, y, z,
                    elevation: z,
                    source: 'POINT entity'
                });
            }
        }
    },
    
    extractElevation(text, x, y) {
        const patterns = [
            { name: 'NE=XXX', regex: /NE\s*=\s*(\d{1,3}[.,]\d{1,2})/i },
            { name: 'NGF=XXX', regex: /NGF\s*=\s*(\d{1,3}[.,]\d{1,2})/i },
            { name: 'Z=XXX', regex: /Z\s*=\s*(\d{1,3}[.,]\d{1,2})/i },
            { name: 'XXX.XX', regex: /^(\d{1,3}[.,]\d{1,2})$/ },
            { name: 'XXX.XXm', regex: /(\d{1,3}[.,]\d{1,2})\s*m/i }
        ];
        
        for (const pattern of patterns) {
            const match = text.match(pattern.regex);
            if (match) {
                const elevStr = match[1].replace(',', '.');
                const elevation = parseFloat(elevStr);
                
                if (elevation > 0 && elevation < 5000) {
                    this.state.points.push({
                        x, y,
                        z: elevation,
                        elevation,
                        text,
                        source: pattern.name
                    });
                    this.log(`‚úì Altitude: "${text}" = ${elevation}m`, 'success');
                    break;
                }
            }
        }
    },
    
    init3D() {
        const canvas = document.getElementById('canvas3d');
        const width = canvas.parentElement.offsetWidth;
        const height = canvas.parentElement.offsetHeight;
        
        this.state.scene = new THREE.Scene();
        this.state.scene.background = new THREE.Color(0x1f2937);
        
        this.state.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100000);
        this.state.camera.position.set(500, 500, 500);
        
        this.state.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        this.state.renderer.setSize(width, height);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.state.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1000, 2000, 1000);
        this.state.scene.add(directionalLight);
        
        const gridHelper = new THREE.GridHelper(1000, 50, 0x888888, 0x444444);
        gridHelper.name = 'grid';
        this.state.scene.add(gridHelper);
        
        this.setupControls();
        this.animate();
    },
    
    render3D() {
        this.state.meshes.forEach(mesh => this.state.scene.remove(mesh));
        this.state.meshes = [];
        
        const exag = this.state.exaggeration;
        
        // Calculer altitude moyenne
        let avgElev = 0;
        if (this.state.points.length > 0) {
            avgElev = this.state.points.reduce((sum, p) => sum + p.elevation, 0) / this.state.points.length;
        }
        
        this.log(`üìê Rendu 3D: ${this.state.entities.length} entit√©s, exag ${exag}x`, 'info');
        
        // Rendu entit√©s
        this.state.entities.forEach(entity => {
            if (entity.type === 'LINE') {
                const points = [
                    new THREE.Vector3(entity.vertices[0].x, 0, entity.vertices[0].y),
                    new THREE.Vector3(entity.vertices[1].x, 0, entity.vertices[1].y)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                const line = new THREE.Line(geometry, material);
                this.state.scene.add(line);
                this.state.meshes.push(line);
            }
            else if (entity.type === 'POLYLINE') {
                const points = entity.vertices.map(v => new THREE.Vector3(v.x, 0, v.y));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                const line = new THREE.Line(geometry, material);
                this.state.scene.add(line);
                this.state.meshes.push(line);
            }
            else if (entity.type === 'CIRCLE') {
                const curve = new THREE.EllipseCurve(
                    entity.center.x, entity.center.y,
                    entity.radius, entity.radius,
                    0, 2 * Math.PI, false, 0
                );
                const points = curve.getPoints(50).map(p => new THREE.Vector3(p.x, 0, p.y));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
                const line = new THREE.LineLoop(geometry, material);
                this.state.scene.add(line);
                this.state.meshes.push(line);
            }
        });
        
        // Rendu points
        this.state.points.forEach(point => {
            const geometry = new THREE.SphereGeometry(5, 16, 16);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const z3d = (point.elevation - avgElev) * exag;
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(point.x, z3d, point.y);
            this.state.scene.add(sphere);
            this.state.meshes.push(sphere);
        });
        
        this.fitCamera();
        this.log(`‚úÖ Rendu 3D termin√©`, 'success');
    },
    
    setupControls() {
        const canvas = document.getElementById('canvas3d');
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        let isRightClick = false;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            isRightClick = e.button === 2;
            previousMouse = { x: e.clientX, y: e.clientY };
            e.preventDefault();
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - previousMouse.x;
            const deltaY = e.clientY - previousMouse.y;
            
            if (isRightClick) {
                const distance = this.state.camera.position.length();
                const factor = distance * 0.001;
                this.state.camera.position.x -= deltaX * factor;
                this.state.camera.position.y += deltaY * factor;
            } else {
                const rotationSpeed = 0.005;
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(this.state.camera.position);
                spherical.theta -= deltaX * rotationSpeed;
                spherical.phi -= deltaY * rotationSpeed;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                this.state.camera.position.setFromSpherical(spherical);
                this.state.camera.lookAt(0, 0, 0);
            }
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        canvas.addEventListener('mouseup', () => { isDragging = false; });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const distance = this.state.camera.position.length();
            const newDistance = distance * (1 + (e.deltaY > 0 ? 0.1 : -0.1));
            this.state.camera.position.multiplyScalar(newDistance / distance);
        });
    },
    
    fitCamera() {
        if (this.state.meshes.length === 0) return;
        const box = new THREE.Box3();
        this.state.meshes.forEach(mesh => box.expandByObject(mesh));
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const distance = maxDim * 1.5;
        this.state.camera.position.set(center.x + distance, center.y + distance, center.z + distance);
        this.state.camera.lookAt(center);
    },
    
    animate() {
        requestAnimationFrame(() => this.animate());
        if (this.state.renderer && this.state.scene && this.state.camera) {
            this.state.renderer.render(this.state.scene, this.state.camera);
        }
    },
    
    exportDXF() {
        if (!this.state.points.length) return alert('Aucun point √† exporter');
        let dxf = "0\nSECTION\n2\nENTITIES\n";
        this.state.points.forEach(p => {
            dxf += `0\nPOINT\n8\nPOINTS_3D\n10\n${p.x.toFixed(3)}\n20\n${p.y.toFixed(3)}\n30\n${p.z.toFixed(3)}\n`;
        });
        dxf += "0\nENDSEC\n0\nEOF\n";
        this.downloadFile(dxf, 'topocad_3d.dxf', 'application/dxf');
        this.log(`‚úÖ Export DXF: ${this.state.points.length} points`, 'success');
    },
    
    exportCSV() {
        if (!this.state.points.length) return alert('Aucun point √† exporter');
        let csv = 'ID,X,Y,Z,Text,Source\n';
        this.state.points.forEach((p, i) => {
            csv += `${i+1},${p.x.toFixed(3)},${p.y.toFixed(3)},${p.z.toFixed(3)},"${p.text || ''}",${p.source}\n`;
        });
        this.downloadFile(csv, 'topocad_points.csv', 'text/csv');
        this.log(`‚úÖ Export CSV: ${this.state.points.length} points`, 'success');
    },
    
    downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    },
    
    updateStats() {
        document.getElementById('statEntities').textContent = this.state.entities.length;
        document.getElementById('statPoints').textContent = this.state.points.length;
        if (this.state.points.length) {
            const elevs = this.state.points.map(p => p.elevation);
            document.getElementById('statMinElev').textContent = Math.min(...elevs).toFixed(2) + 'm';
            document.getElementById('statMaxElev').textContent = Math.max(...elevs).toFixed(2) + 'm';
        }
    },
    
    showLoading(show) {
        document.getElementById('loadingIndicator').classList.toggle('hidden', !show);
    },
    
    showError(message) {
        const alert = document.getElementById('errorAlert');
        if (message) {
            alert.innerHTML = `<strong>‚ùå Erreur:</strong><br>${message}<br><br>
            <strong>Solutions:</strong><br>
            ‚Ä¢ V√©rifiez que c'est un fichier DXF ASCII<br>
            ‚Ä¢ R√©exportez depuis AutoCAD: "Enregistrer sous ‚Üí DXF R2018"<br>
            ‚Ä¢ Essayez avec LibreCAD`;
            alert.classList.remove('hidden');
        } else {
            alert.classList.add('hidden');
        }
    },
    
    log(message, type = 'info') {
        const content = document.getElementById('diagnosticContent');
        const time = new Date().toLocaleTimeString();
        const className = `diagnostic-${type}`;
        const line = document.createElement('div');
        line.className = className;
        line.textContent = `[${time}] ${message}`;
        content.appendChild(line);
        content.scrollTop = content.scrollHeight;
        console.log(message);
    }
};

document.addEventListener('DOMContentLoaded', () => {
    APP.log('üöÄ TopoCAD Pro v1.2.1 - Parser DXF robuste', 'success');
    
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) APP.loadFile(e.target.files[0]);
    });
    
    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropzone.classList.add('active');
    });
    dropzone.addEventListener('dragleave', () => {
        dropzone.classList.remove('active');
    });
    dropzone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropzone.classList.remove('active');
        if (e.dataTransfer.files.length > 0) APP.loadFile(e.dataTransfer.files[0]);
    });
    
    document.getElementById('exagSlider').addEventListener('input', (e) => {
        document.getElementById('exagValue').textContent = e.target.value + 'x';
        APP.state.exaggeration = parseFloat(e.target.value);
        if (APP.state.entities.length) APP.render3D();
    });
    
    document.getElementById('showGrid').addEventListener('change', (e) => {
        const grid = APP.state.scene?.getObjectByName('grid');
        if (grid) grid.visible = e.target.checked;
    });
});
    </script>
</body>
</html>
