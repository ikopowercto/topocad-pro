<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TopoCAD Pro v1.3 - Support Complet DXF</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; overflow: hidden; background: #f3f4f6; }
        .app-container { display: flex; flex-direction: column; height: 100vh; }
        .main-content { display: flex; flex: 1; overflow: hidden; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1rem 2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header-content { display: flex; align-items: center; justify-content: space-between; }
        .logo { display: flex; align-items: center; gap: 1rem; }
        .logo-icon { width: 40px; height: 40px; background: white; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; }
        .sidebar { width: 320px; background: white; border-right: 1px solid #e5e7eb; overflow-y: auto; }
        .sidebar-section { padding: 1.5rem; border-bottom: 1px solid #e5e7eb; }
        .section-title { font-size: 0.875rem; font-weight: 600; color: #374151; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 1rem; }
        .viewer-container { flex: 1; position: relative; background: #1f2937; }
        #canvas3d { width: 100%; height: 100%; display: block; }
        .btn { padding: 0.625rem 1.25rem; border-radius: 0.5rem; border: none; font-weight: 500; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; }
        .btn-success { background: #10b981; color: white; }
        .btn-secondary { background: #6b7280; color: white; }
        .input-group { margin-bottom: 1rem; }
        .input-label { display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem; }
        input[type="range"] { width: 100%; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 1rem; border-radius: 0.5rem; color: white; margin-bottom: 0.75rem; }
        .stat-value { font-size: 1.5rem; font-weight: 700; }
        .stat-label { font-size: 0.75rem; opacity: 0.9; }
        .diagnostic-panel { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 1rem; max-height: 400px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.75rem; }
        .diagnostic-success { color: #059669; }
        .diagnostic-info { color: #3b82f6; }
        .diagnostic-warning { color: #f59e0b; }
        .diagnostic-error { color: #dc2626; }
        .dropzone { border: 2px dashed #d1d5db; border-radius: 0.5rem; padding: 2rem; text-align: center; cursor: pointer; transition: all 0.2s; background: #f9fafb; }
        .dropzone:hover { border-color: #3b82f6; background: #eff6ff; }
        .dropzone.active { border-color: #3b82f6; background: #dbeafe; }
        .hidden { display: none !important; }
        .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; }
        .spinner { border: 3px solid #f3f4f6; border-top: 3px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-icon">üìê</div>
                    <div>
                        <h1 style="font-size: 1.5rem; font-weight: 700;">TopoCAD Pro v1.3</h1>
                        <p style="font-size: 0.875rem; opacity: 0.9;">Support POLYLINE/VERTEX Complet</p>
                    </div>
                </div>
            </div>
        </header>
        
        <div class="main-content">
            <aside class="sidebar">
                <div class="sidebar-section">
                    <h2 class="section-title">üì• Import DXF</h2>
                    <div class="dropzone" id="dropzone">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">üìÅ</div>
                        <p style="font-weight: 600; margin-bottom: 0.5rem;">Glissez votre DXF ici</p>
                        <input type="file" id="fileInput" accept=".dxf" class="hidden">
                        <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">üìÅ Choisir DXF</button>
                    </div>
                    <div id="loadingIndicator" class="hidden" style="margin-top: 1rem;">
                        <div class="spinner"></div>
                        <p style="text-align: center; margin-top: 0.5rem; font-size: 0.875rem;">Chargement...</p>
                    </div>
                </div>
                
                <div class="sidebar-section">
                    <h2 class="section-title">üîç Diagnostic</h2>
                    <div id="diagnosticPanel" class="diagnostic-panel">
                        <div id="diagnosticContent">üöÄ TopoCAD Pro v1.3 - Pr√™t</div>
                    </div>
                </div>
                
                <div class="sidebar-section hidden" id="statsSection">
                    <h2 class="section-title">üìä Statistiques</h2>
                    <div class="grid-2">
                        <div class="stat-card">
                            <div class="stat-value" id="statPolylines">0</div>
                            <div class="stat-label">Polylignes</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="statVertices">0</div>
                            <div class="stat-label">Vertices 3D</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div style="display: flex; justify-content: space-between;">
                            <div><strong>Min:</strong> <span id="statMinZ">-</span></div>
                            <div><strong>Max:</strong> <span id="statMaxZ">-</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="sidebar-section hidden" id="params3DSection">
                    <h2 class="section-title">‚öôÔ∏è Param√®tres 3D</h2>
                    <div class="input-group">
                        <label class="input-label">Exag√©ration verticale: <span id="exagValue">2x</span></label>
                        <input type="range" id="exagSlider" min="1" max="10" value="2" step="0.5">
                    </div>
                    <div class="input-group">
                        <label class="input-label">
                            <input type="checkbox" id="showGrid" checked> Grille
                        </label>
                    </div>
                </div>
                
                <div class="sidebar-section hidden" id="exportSection">
                    <h2 class="section-title">üíæ Export</h2>
                    <button class="btn btn-success" style="width: 100%; margin-bottom: 0.5rem;" onclick="APP.exportDXF()">üì¶ Export DXF 3D</button>
                    <button class="btn btn-secondary" style="width: 100%;" onclick="APP.exportCSV()">üìÑ Export CSV</button>
                </div>
            </aside>
            
            <div class="viewer-container">
                <canvas id="canvas3d"></canvas>
                <div id="noDataMessage" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white;">
                    <div style="font-size: 4rem; margin-bottom: 1rem;">üìê</div>
                    <h2 style="font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem;">TopoCAD Pro v1.3</h2>
                    <p style="font-size: 1rem; opacity: 0.8;">Importez votre fichier DXF</p>
                </div>
            </div>
        </div>
    </div>

    <script>
const APP = {
    state: {
        polylines: [],
        vertices: [],
        scene: null,
        camera: null,
        renderer: null,
        meshes: [],
        exaggeration: 2
    },
    
    async loadFile(file) {
        try {
            this.showLoading(true);
            this.log(`üìÇ Chargement ${file.name} (${(file.size/1024/1024).toFixed(1)} MB)`, 'info');
            
            const text = await file.text();
            this.log(`‚úÖ Fichier lu: ${(text.length/1024).toFixed(0)} KB`, 'success');
            
            this.parseDXF(text);
            this.showLoading(false);
        } catch (error) {
            this.log(`‚ùå ERREUR: ${error.message}`, 'error');
            this.showLoading(false);
        }
    },
    
    parseDXF(text) {
        this.log(`üîç Parsing DXF...`, 'info');
        
        // Supprimer les \r et split par lignes
        const lines = text.replace(/\r/g, '').split('\n').map(l => l.trim());
        
        this.state.polylines = [];
        this.state.vertices = [];
        
        let inEntities = false;
        let currentPolyline = null;
        let currentVertex = null;
        let groupCode = null;
        let i = 0;
        
        while (i < lines.length) {
            const line = lines[i];
            
            // D√©tection section ENTITIES
            if (line === 'ENTITIES') {
                inEntities = true;
                this.log(`‚úì Section ENTITIES trouv√©e`, 'success');
                i++;
                continue;
            }
            
            if (line === 'ENDSEC' && inEntities) {
                // Finaliser la derni√®re polyline
                if (currentPolyline && currentPolyline.vertices.length > 0) {
                    this.state.polylines.push(currentPolyline);
                }
                break;
            }
            
            if (!inEntities) {
                i++;
                continue;
            }
            
            // Lecture par paires (code, valeur)
            if (i + 1 < lines.length) {
                groupCode = lines[i];
                const value = lines[i + 1];
                
                // Code 0 = nouvelle entit√©
                if (groupCode.trim() === '0') {
                    const entityType = value.trim();
                    
                    if (entityType === 'POLYLINE') {
                        // Sauvegarder la polyline pr√©c√©dente
                        if (currentPolyline && currentPolyline.vertices.length > 0) {
                            this.state.polylines.push(currentPolyline);
                        }
                        
                        currentPolyline = {
                            type: 'POLYLINE',
                            layer: '',
                            vertices: []
                        };
                    }
                    else if (entityType === 'VERTEX') {
                        currentVertex = { x: 0, y: 0, z: 0 };
                    }
                    else if (entityType === 'SEQEND') {
                        // Fin de la polyline
                        if (currentPolyline && currentPolyline.vertices.length > 0) {
                            this.state.polylines.push(currentPolyline);
                        }
                        currentPolyline = null;
                    }
                }
                // Layer
                else if (groupCode.trim() === '8') {
                    if (currentPolyline) {
                        currentPolyline.layer = value;
                    }
                }
                // Coordonn√©es VERTEX
                else if (currentVertex) {
                    if (groupCode.trim() === '10') {
                        currentVertex.x = parseFloat(value);
                    } else if (groupCode.trim() === '20') {
                        currentVertex.y = parseFloat(value);
                    } else if (groupCode.trim() === '30') {
                        currentVertex.z = parseFloat(value);
                        
                        // Vertex complet, l'ajouter
                        if (currentPolyline) {
                            currentPolyline.vertices.push({...currentVertex});
                            this.state.vertices.push({...currentVertex});
                        }
                        currentVertex = null;
                    }
                }
                
                i += 2; // Avancer de 2 lignes (code + valeur)
            } else {
                i++;
            }
        }
        
        this.log(`‚úÖ ${this.state.polylines.length} polylignes trouv√©es`, 'success');
        this.log(`‚úÖ ${this.state.vertices.length} vertices 3D extraits`, 'success');
        
        if (this.state.vertices.length === 0) {
            this.log(`‚ö†Ô∏è Aucun vertex 3D (Z) trouv√©`, 'warning');
        }
        
        this.updateStats();
        this.init3D();
        this.render3D();
        
        document.getElementById('statsSection').classList.remove('hidden');
        document.getElementById('params3DSection').classList.remove('hidden');
        document.getElementById('exportSection').classList.remove('hidden');
        document.getElementById('noDataMessage').classList.add('hidden');
    },
    
    init3D() {
        const canvas = document.getElementById('canvas3d');
        const width = canvas.parentElement.offsetWidth;
        const height = canvas.parentElement.offsetHeight;
        
        this.state.scene = new THREE.Scene();
        this.state.scene.background = new THREE.Color(0x1f2937);
        
        this.state.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100000);
        this.state.camera.position.set(500, 500, 500);
        
        this.state.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        this.state.renderer.setSize(width, height);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.state.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1000, 2000, 1000);
        this.state.scene.add(directionalLight);
        
        const gridHelper = new THREE.GridHelper(1000, 50, 0x888888, 0x444444);
        gridHelper.name = 'grid';
        this.state.scene.add(gridHelper);
        
        this.setupControls();
        this.animate();
    },
    
    render3D() {
        this.state.meshes.forEach(mesh => this.state.scene.remove(mesh));
        this.state.meshes = [];
        
        const exag = this.state.exaggeration;
        
        // Calculer Z moyen
        let minZ = Infinity, maxZ = -Infinity;
        this.state.vertices.forEach(v => {
            if (v.z < minZ) minZ = v.z;
            if (v.z > maxZ) maxZ = v.z;
        });
        const avgZ = (minZ + maxZ) / 2;
        
        this.log(`üìê Rendu: Z min=${minZ.toFixed(2)}, max=${maxZ.toFixed(2)}, avg=${avgZ.toFixed(2)}`, 'info');
        
        // Calculer offset X,Y pour centrer
        const allX = this.state.vertices.map(v => v.x);
        const allY = this.state.vertices.map(v => v.y);
        const minX = Math.min(...allX);
        const minY = Math.min(...allY);
        const offsetX = minX;
        const offsetY = minY;
        
        this.log(`üìê Offset: X=${offsetX.toFixed(0)}, Y=${offsetY.toFixed(0)}`, 'info');
        
        // Rendu des polylignes
        this.state.polylines.forEach((polyline, idx) => {
            if (polyline.vertices.length < 2) return;
            
            const points = polyline.vertices.map(v => {
                const x3d = v.x - offsetX;
                const y3d = v.y - offsetY;
                const z3d = (v.z - avgZ) * exag;
                return new THREE.Vector3(x3d, z3d, y3d);
            });
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: this.getColorForLayer(polyline.layer),
                linewidth: 1
            });
            const line = new THREE.Line(geometry, material);
            this.state.scene.add(line);
            this.state.meshes.push(line);
            
            if (idx % 100 === 0) {
                this.log(`  Rendu polyline ${idx+1}/${this.state.polylines.length}`, 'info');
            }
        });
        
        this.log(`‚úÖ ${this.state.meshes.length} polylignes rendues`, 'success');
        
        this.fitCamera();
    },
    
    getColorForLayer(layer) {
        const colors = {
            'AVAL_MNT': 0x00ff00,
            'AMONT_MNT': 0x00ffff,
            'TN_': 0xffff00,
            'default': 0x888888
        };
        
        for (const key in colors) {
            if (layer.includes(key)) return colors[key];
        }
        return colors.default;
    },
    
    setupControls() {
        const canvas = document.getElementById('canvas3d');
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        let isRightClick = false;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            isRightClick = e.button === 2;
            previousMouse = { x: e.clientX, y: e.clientY };
            e.preventDefault();
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - previousMouse.x;
            const deltaY = e.clientY - previousMouse.y;
            
            if (isRightClick) {
                const distance = this.state.camera.position.length();
                const factor = distance * 0.001;
                this.state.camera.position.x -= deltaX * factor;
                this.state.camera.position.y += deltaY * factor;
            } else {
                const rotationSpeed = 0.005;
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(this.state.camera.position);
                spherical.theta -= deltaX * rotationSpeed;
                spherical.phi -= deltaY * rotationSpeed;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                this.state.camera.position.setFromSpherical(spherical);
                this.state.camera.lookAt(0, 0, 0);
            }
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        canvas.addEventListener('mouseup', () => { isDragging = false; });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const distance = this.state.camera.position.length();
            const newDistance = distance * (1 + (e.deltaY > 0 ? 0.1 : -0.1));
            this.state.camera.position.multiplyScalar(newDistance / distance);
        });
    },
    
    fitCamera() {
        if (this.state.meshes.length === 0) return;
        const box = new THREE.Box3();
        this.state.meshes.forEach(mesh => box.expandByObject(mesh));
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const distance = maxDim * 1.5;
        this.state.camera.position.set(center.x + distance, center.y + distance, center.z + distance);
        this.state.camera.lookAt(center);
    },
    
    animate() {
        requestAnimationFrame(() => this.animate());
        if (this.state.renderer && this.state.scene && this.state.camera) {
            this.state.renderer.render(this.state.scene, this.state.camera);
        }
    },
    
    exportDXF() {
        if (!this.state.vertices.length) return alert('Aucun vertex √† exporter');
        
        let dxf = "0\nSECTION\n2\nENTITIES\n";
        
        this.state.polylines.forEach(poly => {
            dxf += `0\nPOLYLINE\n8\n${poly.layer}\n66\n1\n`;
            poly.vertices.forEach(v => {
                dxf += `0\nVERTEX\n8\n${poly.layer}\n10\n${v.x.toFixed(3)}\n20\n${v.y.toFixed(3)}\n30\n${v.z.toFixed(3)}\n`;
            });
            dxf += `0\nSEQEND\n`;
        });
        
        dxf += "0\nENDSEC\n0\nEOF\n";
        
        this.downloadFile(dxf, 'topocad_3d.dxf', 'application/dxf');
        this.log(`‚úÖ Export DXF: ${this.state.polylines.length} polylignes`, 'success');
    },
    
    exportCSV() {
        if (!this.state.vertices.length) return alert('Aucun vertex √† exporter');
        
        let csv = 'ID,X,Y,Z\n';
        this.state.vertices.forEach((v, i) => {
            csv += `${i+1},${v.x.toFixed(3)},${v.y.toFixed(3)},${v.z.toFixed(3)}\n`;
        });
        
        this.downloadFile(csv, 'topocad_vertices.csv', 'text/csv');
        this.log(`‚úÖ Export CSV: ${this.state.vertices.length} vertices`, 'success');
    },
    
    downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    },
    
    updateStats() {
        document.getElementById('statPolylines').textContent = this.state.polylines.length;
        document.getElementById('statVertices').textContent = this.state.vertices.length;
        
        if (this.state.vertices.length) {
            const zValues = this.state.vertices.map(v => v.z);
            document.getElementById('statMinZ').textContent = Math.min(...zValues).toFixed(2) + 'm';
            document.getElementById('statMaxZ').textContent = Math.max(...zValues).toFixed(2) + 'm';
        }
    },
    
    showLoading(show) {
        document.getElementById('loadingIndicator').classList.toggle('hidden', !show);
    },
    
    log(message, type = 'info') {
        const content = document.getElementById('diagnosticContent');
        const time = new Date().toLocaleTimeString();
        const className = `diagnostic-${type}`;
        const line = document.createElement('div');
        line.className = className;
        line.textContent = `[${time}] ${message}`;
        content.appendChild(line);
        content.scrollTop = content.scrollHeight;
        console.log(message);
    }
};

document.addEventListener('DOMContentLoaded', () => {
    APP.log('üöÄ TopoCAD Pro v1.3 - Support POLYLINE/VERTEX', 'success');
    
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) APP.loadFile(e.target.files[0]);
    });
    
    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropzone.classList.add('active');
    });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('active'));
    dropzone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropzone.classList.remove('active');
        if (e.dataTransfer.files.length > 0) APP.loadFile(e.dataTransfer.files[0]);
    });
    
    document.getElementById('exagSlider').addEventListener('input', (e) => {
        document.getElementById('exagValue').textContent = e.target.value + 'x';
        APP.state.exaggeration = parseFloat(e.target.value);
        if (APP.state.polylines.length) APP.render3D();
    });
    
    document.getElementById('showGrid').addEventListener('change', (e) => {
        const grid = APP.state.scene?.getObjectByName('grid');
        if (grid) grid.visible = e.target.checked;
    });
});
    </script>
</body>
</html>
